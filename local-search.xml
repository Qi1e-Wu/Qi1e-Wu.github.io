<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode-68-text-justification</title>
    <link href="/2024/12/06/leetcode-68-text-justification/"/>
    <url>/2024/12/06/leetcode-68-text-justification/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给定一个单词数组 <code>words</code> 和一个长度 <code>maxWidth</code> ，重新排版单词，使其成为每行恰好有 <code>maxWidth</code> 个字符，且左右两端对齐的文本。</p><p>你应该使用 <strong>“贪心算法”</strong> 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>&#39; &#39;</code> 填充，使得每行恰好有 <em>maxWidth</em> 个字符。</p><p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p><p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外</strong>的空格。</p><p>注意:</p><p>单词是指由非空格字符组成的字符序列。<br>每个单词的长度大于 0，小于等于 <em>maxWidth</em>。<br>输入单词数组 <code>words</code> 至少包含一个单词。</p><p>示例：</p><blockquote><p>输入: words &#x3D; [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”], maxWidth &#x3D; 16<br>输出:<br>[<br>  <code>&quot;This    is    an&quot;,</code><br>  <code>&quot;example  of text&quot;,</code><br>  <code>&quot;justification.  &quot;</code><br>]</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这里主要使用的方法是模拟，但是其中需要注意不少的细节。<br>主要采用的办法是双指针，用一个指针记录当前需要插入的字符串的起始位置，然后让另一个指针不断地前移，直到当前子字符串的长度大于目标长度。<br>需要注意的是因为每个单词之间至少有一个空格，所有在判定的时候还需要加上（i - j）的长度。<br>于是我们可以得到代码框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, curLen = words[<span class="hljs-number">0</span>].length();<span class="hljs-comment">//初始化首个单词的长度</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">wordlen</span> <span class="hljs-operator">=</span> words[i].length();<br>    curLen += wordlen;<span class="hljs-comment">//依次累加</span><br>    <span class="hljs-keyword">if</span>(curLen + (i - j)&gt; maxWidth)&#123;<span class="hljs-comment">//当前累计单词加上空格的长度大于目标长度</span><br>        <span class="hljs-comment">//这里放处理逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后定义处理逻辑，首先当进入判定的时候，当前字符串长度已经超过目标长度了，因此快指针i必须往后退一个单词。<br>同时我们记录当前已经纳入范围的单词数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<span class="hljs-comment">//记录回退一格</span><br>curLen -= wordlen;<span class="hljs-comment">//当前长度回退</span><br><span class="hljs-type">int</span> <span class="hljs-variable">space</span> <span class="hljs-operator">=</span> maxWidth - curLen;<span class="hljs-comment">//记录需要填充的空格数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">numOfSpace</span> <span class="hljs-operator">=</span> k - j;<span class="hljs-comment">//记录需要插入几个空，例如纳入了四个单词，就需要插入三个空</span><br></code></pre></td></tr></table></figure><p>定义一个工具类用于生成符合要求的空格字符串数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] splitSpaces(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">spaces</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span>.repeat(n);<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;spaces&#125;;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">baseLength</span> <span class="hljs-operator">=</span> n / k;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">extra</span> <span class="hljs-operator">=</span> n % k;<br><br>        String[] parts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">partLength</span> <span class="hljs-operator">=</span> baseLength + (i &lt; extra ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>            parts[i] = spaces.substring(index, index + partLength);<br>            index += partLength;<br>        &#125;<br>        <span class="hljs-keyword">return</span> parts;<br>    &#125;<br></code></pre></td></tr></table></figure><p>随后进行题示的处理逻辑，每添加一个单词，j就前移，并添加一个对应的空格。<br>目标字符串写入返回值之后重置curLen变量为当前j指向的字符串长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(String s : spaces)&#123;<br>    sb.append(words[j++]);<br>    sb.append(s);<br>&#125;<br><span class="hljs-keyword">if</span>(sb.length() + words[j].length() &lt;= maxWidth)<br>    sb.append(words[j++]);<br>ans.add(sb.toString());<br>curLen = words[j].length();<br></code></pre></td></tr></table></figure><p>这个时候，由于j停留在上一个处理完的位置，因此最后一行是不会被加入字符串的，因此单独处理即可，因为剩余的部分长度一定是小于目标值，因此只要在写入单词之后加上一个空格即可。<br>最后判断目前长度是否大于maxLen，如果是，则将trim后的字符串加入返回值，如果不是，则补上空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">while</span>(j &lt; n)&#123;<br>    sb.append(words[j++]);<br>    sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(sb.length() &gt; maxWidth)&#123;<br>    ans.add(sb.toString().trim());<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">while</span>(maxWidth &gt; sb.length())&#123;<br>        sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    ans.add(sb.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">fullJustify</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> maxWidth)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, curLen = words[<span class="hljs-number">0</span>].length();<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wordlen</span> <span class="hljs-operator">=</span> words[i].length();<br>            curLen += wordlen;<br>            <span class="hljs-keyword">if</span>(curLen + (i - j)&gt; maxWidth)&#123;<br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>                curLen -= wordlen;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">space</span> <span class="hljs-operator">=</span> maxWidth - curLen;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">numOfSpace</span> <span class="hljs-operator">=</span> k - j;<br>                String[] spaces = splitSpaces(space, numOfSpace);<br>                <span class="hljs-keyword">for</span>(String s : spaces)&#123;<br>                    sb.append(words[j++]);<br>                    sb.append(s);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(sb.length() + words[j].length() &lt;= maxWidth)<br>                    sb.append(words[j++]);<br>                ans.add(sb.toString());<br>                curLen = words[j].length();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(j &lt; n)&#123;<br>            sb.append(words[j++]);<br>            sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sb.length() &gt; maxWidth)&#123;<br>            ans.add(sb.toString().trim());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(maxWidth &gt; sb.length())&#123;<br>                sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            ans.add(sb.toString());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] splitSpaces(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">spaces</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span>.repeat(n);<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;spaces&#125;;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">baseLength</span> <span class="hljs-operator">=</span> n / k;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">extra</span> <span class="hljs-operator">=</span> n % k;<br><br>        String[] parts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">partLength</span> <span class="hljs-operator">=</span> baseLength + (i &lt; extra ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>            parts[i] = spaces.substring(index, index + partLength);<br>            index += partLength;<br>        &#125;<br>        <span class="hljs-keyword">return</span> parts;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Hard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-19-remove-nth-node-from-end-of-list</title>
    <link href="/2024/12/05/leetcode-19-remove-nth-node-from-end-of-list/"/>
    <url>/2024/12/05/leetcode-19-remove-nth-node-from-end-of-list/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。<br><img src="/img/leetcode-19-remove-nth-node-from-end-of-list-remove_ex1.jpg" alt="示例"></p><blockquote><p><strong>输入：</strong>head &#x3D; [1,2,3,4,5], n &#x3D; 2<br><strong>输出：</strong>[1,2,3,5]</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题在408的数据结构考题中出现过，如果仅仅使用一次遍历就完成操作，即可获得满分（当然这里不用考虑n大于链表长度的问题）。<br>这里考虑使用快慢指针来解决问题，首先定义虚拟节点dummy，快指针先走n步，慢指针随后和快指针一起移动，直到快指针指向最后一个节点。<br>慢指针删除下一个指针即可。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>,head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy, slow = dummy;<br>    <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>)&#123;<br>        fast = fast.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span>)&#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    slow.next = slow.next.next;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-135-candy</title>
    <link href="/2024/12/03/leetcode-135-candy/"/>
    <url>/2024/12/03/leetcode-135-candy/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</li></ul><blockquote><p><strong>输入：</strong>ratings &#x3D; [1,0,2]<br><strong>输出：</strong>5<br><strong>解释：</strong>你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>开辟一个新的数组，用于存放每个孩子拿到的糖果数，然后遍历收集。<br>首先讲新的数组初始化为全1。<br>注意到题目中提到<strong>相邻</strong>两个孩子，评分更高的将会得到更多的糖果，假设三个相邻的孩子分别为i,j,k。那么就有<code>candy[i] &lt;= candy[j] &amp;&amp; candy[j] &gt;= candy[k]</code>。<br>但是同时满足两个条件过于苛刻，而且在数组更新的过程中，左边或者右边的糖果数也会发生变化。<br>那么在一次遍历中，只考虑一边，求出满足<code>candy[i] &lt;= candy[j]</code>或者<code>candy[j] &gt;= candy[k]</code>。<br>遇到评分较大者，在左边（或者右边）孩子的糖果数上+1即可。<br>随后，我们得到了满足大于右边的数组一个，大于左边的数组一个。<br>遍历这两个数组，取其中较大值即为满足条件的最小值。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ratings.length;<br>    <span class="hljs-type">int</span>[] rightCandy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-type">int</span>[] leftCandy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        rightCandy[i] = leftCandy[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>])&#123;<br>            leftCandy[i] = leftCandy[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">if</span>(ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>])&#123;<br>            rightCandy[i] = rightCandy[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        ans += Math.max(rightCandy[i],leftCandy[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Hard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-6-zigzag-conversion</title>
    <link href="/2024/12/02/leetcode-6-zigzag-conversion/"/>
    <url>/2024/12/02/leetcode-6-zigzag-conversion/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p><blockquote><p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;。</code></p></blockquote><blockquote><p><strong>输入：</strong>s &#x3D; “PAYPALISHIRING”, numRows &#x3D; 3<br><strong>输出：</strong>“PAHNAPLSIIGYIR”</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题本质上类似于一个<code>找规律</code>问题，从模拟的角度来讲，字符按照<code>z</code>字形排列，但是在构造返回字符串的时候，是按照行来增加字符的。<br>这就启示我们按照行来寻找规律；首先，我们为每个字符编号，例如对于<code>P</code>，我们将其编号为<code>0</code>。<br>对于之后的<code>A</code>，<code>H</code>，<code>N</code>，我们可以比较容易的为其编号为<code>4</code>，<code>8</code>，<code>12</code>。<br>对于第一行，我们推测它们的间隔均为<code>2 * numRows - 2</code>。<br>对于第二行，我们可以观察到每个字符间隔分别为2，2，2，2······。<br>对于numRows小于等于3的情况来讲，这个规律不明显，这里以一个numRows为4的案例进行展示：</p><blockquote><p><strong>输入：</strong>s &#x3D; “PAYPALISHIRING”, numRows &#x3D; 4<br><strong>输出：</strong>“PINALSIGYAHRPI”<br><strong>解释：</strong><br>P     I    N<br>A   L S  I G<br>Y A   H R<br>P     I</p></blockquote><p>对于第二行，每个字符之间的间隔为4，2，4，2，······<br>对于第三行，每个字符之间的间隔为2，4，2，4，······<br>我们推测每个字符的间隔呈现周期性变化，并且周期为2，周期的间隔之和等于最长间隔，即<strong>2 * numRows - 2</strong><br>除开第一行和最后一行，每一行的间隔都以2为步长进行递减，而且间隔在每一行的元素添加中<strong>保持不变</strong><br>因此我们可以分情况进行讨论：<strong>第一行+最后一行</strong>与<strong>其它部分</strong><br>对于第一行和最后一行，只要从0和numRows - 1的位置进行步长为<code>2 * numRows - 2</code>的遍历添加字符即可。<br>对于其余行，设置长度为2的间隔，每添加完一行，则初始步长则会相应减少2（从最长间隔开始递减）<br>每添加一个元素，步长就会变为最长间隔减去上一次步长，即<code>gap = maxLen - gap</code>。<br>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> numRows)</span> &#123;<br>    <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLeap</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * numRows - <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leap</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i += maxLeap)&#123;<br>        sb.append(s.charAt(i));<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; numRows - <span class="hljs-number">1</span>; i++)&#123;<br>        leap += <span class="hljs-number">2</span>;<br>        gap = maxLeap - leap;<br>        gap = maxLeap - gap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;j &lt; n;j += gap)&#123;<br>            gap = maxLeap - gap;<br>            sb.append(s.charAt(j));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> numRows - <span class="hljs-number">1</span>; i &lt; n; i += maxLeap)&#123;<br>        sb.append(s.charAt(i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-209-minimum-size-subarray-sum</title>
    <link href="/2024/12/01/leetcode-209-minimum-size-subarray-sum/"/>
    <url>/2024/12/01/leetcode-209-minimum-size-subarray-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的<br>子数组<br> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><blockquote><p><strong>输入：</strong>target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br><strong>输出：</strong>2<br><strong>解释：</strong>子数组 <code>[4,3]</code> 是该条件下的长度最小的子数组。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>看到子数组问题，可以往两个方向去想：前缀和或者滑动窗口。<br>本题也可以使用前缀和来解决，但是会额外消耗O(n)的空间。<br>这里选择维护一个长度为j - i的滑动窗口。</p><ul><li>首先j从0出发，每遇到一个元素就累加一次子数组之和。</li><li>直到子数组之和大于目标值，记录目前子数组的长度</li><li>从i开头删减元素，再次记录子数组的长度</li><li>最后返回最短子数组的长度</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x7fffffff</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j ++)&#123;<br>        sum += nums[j];<br>        <span class="hljs-keyword">while</span>(sum &gt;= target)&#123;<br>            min = Math.min(min, j - i + <span class="hljs-number">1</span>);<br>            sum -= nums[i++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> min==<span class="hljs-number">0x7fffffff</span>?<span class="hljs-number">0</span>:min;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 48 rotate image</title>
    <link href="/2024/11/30/leetcode-48-rotate-image/"/>
    <url>/2024/11/30/leetcode-48-rotate-image/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给定一个 <code>n × n</code> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 <code>原地</code> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><img src="/img/leetcode-48-rotate-image-mat2.jpg" alt="示例"></p><blockquote><p><strong>输入：</strong> matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br><strong>输出：</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><em><strong>寻找交换过程中的循环不变量</strong></em><br>修改一个矩阵之中的元素，一般需要双重循环，通常我们将i作为横坐标，j作为纵坐标，于是，我们可以首先写出如下的代码框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n - i - <span class="hljs-number">1</span>; j++)&#123;<br>            <span class="hljs-comment">//这里放旋转矩阵的处理逻辑</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么是n-1和n-i-1而不是n和n-i？这里和每个人的处理逻辑有关，我的思路是按照“一圈一圈”的规则去处理，对于每一行的最后一个元素（即n-1还有n-i-1），在处理0和i的时候已经被交换过了。</p><p>那么问题在于，如何处理这个<code>旋转90度的操作</code>？</p><p>首先我们从一般情况看起，对于示例的矩阵，<br><code>(i,j)</code>代表矩阵元素<code>matrix[i][j]</code></p><ul><li>第一次交换： (<strong>0</strong>,0) -&gt; (3,0), (3,<strong>0</strong>) -&gt; (3,3), (<strong>3</strong>,3) -&gt; (0,3), (0,<strong>3</strong>) -&gt; (0,0)</li><li>第二次交换： (<strong>0</strong>,1) -&gt; (2,0), (2,<strong>0</strong>) -&gt; (3,2), (<strong>3</strong>,2) -&gt; (1,3), (1,<strong>3</strong>) -&gt; (0,1)</li><li>第三次交换： (<strong>0</strong>,2) -&gt; (1,0), (1,<strong>0</strong>) -&gt; (3,1), (<strong>3</strong>,1) -&gt; (2,3), (2,<strong>3</strong>) -&gt; (0,2)</li></ul><p>可以直观地看到，每一次交换，都涉及到4个元素，每一轮交换，则与j的循环次数有关。除此之外呢？</p><blockquote><p><strong>一次交换：</strong> 例如涉及到的4个元素按照要求进行90度旋转，被称为一次交换<br><strong>一轮交换：</strong> 这一行所有的元素都进行过交换之后，则被称为一轮交换</p></blockquote><p>我们可以看到，在每一次交换中，总有一部分坐标是不会发生改变的，这一部分坐标就是我们要求寻找的循环不变量，它在一轮交换中不发生改变，仅仅在外层循环改变的时候，才会发生变动。<br>这个时候，我们就可以比较容易的知道，与i有关的参数，就是本轮交换中的不变量，我们把握好这一部分不变量，就可以写出相应的代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//一次交换的相应逻辑</span><br>matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>matrix[n - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>];<br>matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>] = matrix[j][n - i - <span class="hljs-number">1</span>];<br>matrix[j][n - i - <span class="hljs-number">1</span>] = tmp;<br></code></pre></td></tr></table></figure><p>题解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n - i - <span class="hljs-number">1</span>; j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>            matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>            matrix[n - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>];<br>            matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>] = matrix[j][n - i - <span class="hljs-number">1</span>];<br>            matrix[j][n - i - <span class="hljs-number">1</span>] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 152 maximum product subarray</title>
    <link href="/2024/11/29/leetcode-152-maximum-product-subarray/"/>
    <url>/2024/11/29/leetcode-152-maximum-product-subarray/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续<br>子数组<br>（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p><blockquote><p><strong>输入:</strong> nums &#x3D; [2,3,-2,4]<br><strong>输出:</strong> 6<br><strong>解释:</strong> 子数组 [2,3] 有最大乘积 6。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>收到官方题解评论区的一位网友的启发，得到一个十分精妙的思路：</p><p>首先，乘积最大的数组，一定满足如下条件：</p><ul><li>其边缘一定为数组的边界或者是0。</li></ul><p>为什么？</p><p>使用反证法证明，如果一个乘积最大的数组，其两边的数均不为0，那这个数组一共会产生四种情况：</p><ul><li>左边为正数，右边为负数；那么这个数组乘以左边的数就一定会大于等于当前子数组的乘积，与假设矛盾。</li><li>右边为正数，左边为负数，和上一种情况一样。</li><li>左右均为正数。</li><li>左右均为负数，此时数组同时向左右两边扩展，得到的乘积也一定大于原本的数组，与假设矛盾。</li></ul><p>故我们可以知道，乘积最大的数组一定是从边界出发或者左右两端为0的数组。</p><p>因此我们可以首先从最左侧出发，依次累乘数组中所有的元素，在遇到0的时候，清空之前保存的乘积记录从1重新开始（相当于把子数组的左端移动到0的位置）<br>再从最右侧出发，遍历从右端开始的乘积。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xffffffff</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        product *= nums[i];<br>        ans = Math.max(ans, product);<br>        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>            product = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    product = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        product *= nums[i];<br>        ans = Math.max(ans, product);<br>        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>            product = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 443 string compression</title>
    <link href="/2024/11/26/leetcode-443-string-compression/"/>
    <url>/2024/11/26/leetcode-443-string-compression/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p><p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong>：</p><ul><li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li><li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。<br>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</li></ul><p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p><p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p><blockquote><p><strong>输入</strong>：chars &#x3D; [“a”,”a”,”b”,”b”,”c”,”c”,”c”]<br><strong>输出</strong>：返回 6 ，输入数组的前 6 个字符应该是：[“a”,”2”,”b”,”2”,”c”,”3”]<br><strong>解释</strong>：”aa” 被 “a2” 替代。”bb” 被 “b2” 替代。”ccc” 被 “c3” 替代。</p></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题看到压缩思路就会想到使用双指针来做，其中快指针i用于扫描所有的重复字符，而慢指针j则用于记录当前修改的位置。</p><p>首先快指针和慢指针都从0出发，快指针一直移动直到和慢指针所指向的字符不同。</p><p>此时快指针指向的位置减去慢指针指向的位置就是重复字符的长度。</p><p>将这段长度转化为字符串再转化为字符数组，再将字符数组中的元素一个个写入慢指针指向的位置。</p><p>特判一下长度为1的时候只要写入字符就可以。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compress</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> chars.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span>(idx &lt; n &amp;&amp; chars[idx] == chars[i]) idx++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> idx - i;<br>        chars[j++] = chars[i];<br>        <span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> idx - i;<br>            <span class="hljs-type">char</span>[] numArray = String.valueOf(len).toCharArray();<br>            <span class="hljs-keyword">for</span>(Character c : numArray)&#123;<br>                chars[j++] = c;<br>            &#125;<br>        &#125;<br>        i = idx;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 2130 maximum twin sum of a linked list</title>
    <link href="/2024/11/25/leetcode2130-maximum-twin-sum-of-a-linked-list/"/>
    <url>/2024/11/25/leetcode2130-maximum-twin-sum-of-a-linked-list/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>在一个大小为 <code>n</code> 且 <code>n</code> 为 偶数 的链表中，对于 <code>0 &lt;= i &lt;= (n / 2) - 1</code> 的 <code>i</code> ，第 <code>i</code> 个节点（下标从 <code>0</code> 开始）的孪生节点为第 <code>(n-1-i)</code> 个节点 。</p><ul><li>比方说，<code>n = 4</code> 那么节点 <code>0</code> 是节点 <code>3</code> 的孪生节点，节点 <code>1</code> 是节点 <code>2</code> 的孪生节点。这是长度为 <code>n = 4</code> 的链表中所有的孪生节点。</li></ul><p><strong>孪生和</strong> 定义为一个节点和它孪生节点两者值之和。</p><p>给你一个长度为偶数的链表的头节点 <code>head</code> ，请你返回链表的 <strong>最大孪生和</strong> 。<br><img src="/img/leetcode2130-maximum-twin-sum-of-a-linked-list-eg1drawio.png" alt="示例"></p><blockquote><p>输入：head &#x3D; [5,4,2,1]<br>输出：6<br><strong>解释：</strong><br>节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。<br>链表中没有其他孪生节点。<br>所以，链表的最大孪生和是 6 。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>孪生节点的思路类似于在一个数组中设置两个指针，一个从0开始一个从末尾开始相向而行，指针每次移动的数组下标之和则未孪生节点的和。</p><p>一个比较笨的办法是申请一个<code>ArrayList</code>，从<code>head</code>开始遍历链表，将所有的值存入<code>ArrayList</code>之中后按照访问数组的方式来计算。</p><p>但是这样的话会产生额外<code>O(n)</code>的空间。</p><p>在链表中想要从后往前找元素是非常困难的，能不能把换个思路，因为两个指针相向而行，把后一半的链表逆转过来，就可以比较方便地找到一个节点和它对应的孪生节点？</p><p>这里借鉴了<a href="https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/description/">2095.删除链表的中间节点</a>的思路，通过快慢指针来寻找到中间节点，然后把链表一分为二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(ListNode head)</span>&#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">guard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>,head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> guard;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> guard;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>            fast = fast.next;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>            fast = fast.next;<br>        <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">break</span>;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后将后半段链表逆置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.next;<br>        curr.next = prev;<br>        prev = curr;<br>        curr = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><p>两指针相向而行，最后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pairSum</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> findMiddle(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> mid.next;<br>        mid.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">revHead</span> <span class="hljs-operator">=</span> reverseList(tmp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span> &amp;&amp; revHead != <span class="hljs-literal">null</span>)&#123;<br>            max = Math.max(max, head.val + revHead.val);<br>            head = head.next;<br>            revHead = revHead.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br><br>    &#125;<br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">guard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>,head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> guard;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> guard;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>                fast = fast.next;<br>            <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>                fast = fast.next;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">break</span>;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：<code>O(n)</code>需要遍历两次链表<br>空间复杂度：<code>O(1)</code>需要申请常数级空间</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 2352 equal row and column pairs</title>
    <link href="/2024/11/24/leetcode2352-equal-row-and-column-pairs/"/>
    <url>/2024/11/24/leetcode2352-equal-row-and-column-pairs/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给你一个下标从 <code>0 </code>开始、大小为 <code>n x n</code>的整数矩阵 <code>grid</code> ，返回满足 <code>Ri</code> 行和 <code>Cj</code>列相等的行列对 <code>(Ri, Cj)</code> 的数目。<br>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p><p><img src="/img/leetcode2352-equal-row-and-column-pairs-ex1.jpg" alt="示例"></p><blockquote><p><strong>输入</strong>：grid &#x3D; [[3,2,1],[1,7,6],[2,7,7]]<br><strong>输出</strong>：1<br><strong>解释</strong>：存在一对相等行列对：</p><ul><li>(第 2 行，第 1 列)：[2,7,7]</li></ul></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一开始想到的朴素方法是选定一行之后依次比较每一行和每一列，这样的话时间复杂度会上升到$$ (O^3) $$，后续想到可以使用哈希表来做。<br>首先遍历行，将行转化为字符串之后存入哈希表，每遇到相同的字符串对应的值就+1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] row : grid)&#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : row)&#123;<br>        sb.append(num + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    hm.put(sb.toString(), hm.getOrDefault(sb.toString(), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就记录了所有的行和出现的对应次数。<br>随后遍历列，如果列在哈希表中出现，则相同数组的数量则增加对应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        sb.append(grid[j][i] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    ans += hm.getOrDefault(sb.toString(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一个触类旁通的思路"><a href="#一个触类旁通的思路" class="headerlink" title="一个触类旁通的思路"></a>一个触类旁通的思路</h1><p>通过StringBuilder()方法构建需要较高的系统开销。通过模拟哈希的过程则能避免这一点。</p><ul><li>首先选取一个较大的素数作为MODULOUS </li><li>随后选取一个较小的素数作为BASE</li><li>通过计算一行（或者一列）所有元素与BASE的乘积再对MODULOUS取余，则会生成独一无二的哈希值（不考虑碰撞）</li><li>将哈希值存入键值对</li><li>如果列数组计算出相同的哈希值，则认为两行相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BASE</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;  <span class="hljs-comment">// 基数，选择一个较大的质数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MODULUS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;  <span class="hljs-comment">// 模数，选择一个较大的质数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashKey</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            hashKey = (hashKey * BASE + grid[i][j] * (j + <span class="hljs-number">1</span>)) % MODULUS;<br>        &#125;<br>        map.put(hashKey, map.getOrDefault(hashKey, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashKey</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            hashKey = (hashKey * BASE + grid[i][j] * (i + <span class="hljs-number">1</span>)) % MODULUS;<br>        &#125;<br>        ans += map.getOrDefault(hashKey, <span class="hljs-number">0</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mit-6.s081-lab1</title>
    <link href="/2024/11/23/mit-6-s081-lab1/"/>
    <url>/2024/11/23/mit-6-s081-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="INTRO"><a href="#INTRO" class="headerlink" title="INTRO"></a>INTRO</h1><p>这篇blog主要用于记录MIT的操作系统实验(6.S081)Lab1的通过记录</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
