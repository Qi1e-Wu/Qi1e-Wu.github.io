<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode-48-rotate-image</title>
    <link href="/2024/11/30/leetcode-48-rotate-image/"/>
    <url>/2024/11/30/leetcode-48-rotate-image/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给定一个 <code>n × n</code> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 <code>原地</code> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><img src="/img/leetcode-48-rotate-image-mat2.jpg" alt="示例"></p><blockquote><p><strong>输入：</strong> matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br><strong>输出：</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><em><strong>寻找交换过程中的循环不变量</strong></em><br>修改一个矩阵之中的元素，一般需要双重循环，通常我们将i作为横坐标，j作为纵坐标，于是，我们可以首先写出如下的代码框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n - i - <span class="hljs-number">1</span>; j++)&#123;<br>            <span class="hljs-comment">//这里放旋转矩阵的处理逻辑</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么是n-1和n-i-1而不是n和n-i？这里和每个人的处理逻辑有关，我的思路是按照“一圈一圈”的规则去处理，对于每一行的最后一个元素（即n-1还有n-i-1），在处理0和i的时候已经被交换过了。</p><p>那么问题在于，如何处理这个<code>旋转90度的操作</code>？</p><p>首先我们从一般情况看起，对于示例的矩阵，<br><code>(i,j)</code>代表矩阵元素<code>matrix[i][j]</code></p><ul><li>第一次交换： (<strong>0</strong>,0) -&gt; (3,0), (3,<strong>0</strong>) -&gt; (3,3), (<strong>3</strong>,3) -&gt; (0,3), (0,<strong>3</strong>) -&gt; (0,0)</li><li>第二次交换： (<strong>0</strong>,1) -&gt; (2,0), (2,<strong>0</strong>) -&gt; (3,2), (<strong>3</strong>,2) -&gt; (1,3), (1,<strong>3</strong>) -&gt; (0,1)</li><li>第三次交换： (<strong>0</strong>,2) -&gt; (1,0), (1,<strong>0</strong>) -&gt; (3,1), (<strong>3</strong>,1) -&gt; (2,3), (2,<strong>3</strong>) -&gt; (0,2)</li></ul><p>可以直观地看到，每一次交换，都涉及到4个元素，每一轮交换，则与j的循环次数有关。除此之外呢？</p><blockquote><p><strong>一次交换：</strong> 例如涉及到的4个元素按照要求进行90度旋转，被称为一次交换<br><strong>一轮交换：</strong> 这一行所有的元素都进行过交换之后，则被称为一轮交换</p></blockquote><p>我们可以看到，在每一次交换中，总有一部分坐标是不会发生改变的，这一部分坐标就是我们要求寻找的循环不变量，它在一轮交换中不发生改变，仅仅在外层循环改变的时候，才会发生变动。<br>这个时候，我们就可以比较容易的知道，与i有关的参数，就是本轮交换中的不变量，我们把握好这一部分不变量，就可以写出相应的代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//一次交换的相应逻辑</span><br>matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>matrix[n - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>];<br>matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>] = matrix[j][n - i - <span class="hljs-number">1</span>];<br>matrix[j][n - i - <span class="hljs-number">1</span>] = tmp;<br></code></pre></td></tr></table></figure><p>题解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n - i - <span class="hljs-number">1</span>; j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>            matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>            matrix[n - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>];<br>            matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>] = matrix[j][n - i - <span class="hljs-number">1</span>];<br>            matrix[j][n - i - <span class="hljs-number">1</span>] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 152 maximum product subarray</title>
    <link href="/2024/11/29/leetcode-152-maximum-product-subarray/"/>
    <url>/2024/11/29/leetcode-152-maximum-product-subarray/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续<br>子数组<br>（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p><blockquote><p><strong>输入:</strong> nums &#x3D; [2,3,-2,4]<br><strong>输出:</strong> 6<br><strong>解释:</strong> 子数组 [2,3] 有最大乘积 6。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>收到官方题解评论区的一位网友的启发，得到一个十分精妙的思路：</p><p>首先，乘积最大的数组，一定满足如下条件：</p><ul><li>其边缘一定为数组的边界或者是0。</li></ul><p>为什么？</p><p>使用反证法证明，如果一个乘积最大的数组，其两边的数均不为0，那这个数组一共会产生四种情况：</p><ul><li>左边为正数，右边为负数；那么这个数组乘以左边的数就一定会大于等于当前子数组的乘积，与假设矛盾。</li><li>右边为正数，左边为负数，和上一种情况一样。</li><li>左右均为正数。</li><li>左右均为负数，此时数组同时向左右两边扩展，得到的乘积也一定大于原本的数组，与假设矛盾。</li></ul><p>故我们可以知道，乘积最大的数组一定是从边界出发或者左右两端为0的数组。</p><p>因此我们可以首先从最左侧出发，依次累乘数组中所有的元素，在遇到0的时候，清空之前保存的乘积记录从1重新开始（相当于把子数组的左端移动到0的位置）<br>再从最右侧出发，遍历从右端开始的乘积。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xffffffff</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        product *= nums[i];<br>        ans = Math.max(ans, product);<br>        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>            product = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    product = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        product *= nums[i];<br>        ans = Math.max(ans, product);<br>        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>            product = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 443 string compression</title>
    <link href="/2024/11/26/leetcode-443-string-compression/"/>
    <url>/2024/11/26/leetcode-443-string-compression/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p><p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong>：</p><ul><li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li><li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。<br>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</li></ul><p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p><p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p><blockquote><p><strong>输入</strong>：chars &#x3D; [“a”,”a”,”b”,”b”,”c”,”c”,”c”]<br><strong>输出</strong>：返回 6 ，输入数组的前 6 个字符应该是：[“a”,”2”,”b”,”2”,”c”,”3”]<br><strong>解释</strong>：”aa” 被 “a2” 替代。”bb” 被 “b2” 替代。”ccc” 被 “c3” 替代。</p></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题看到压缩思路就会想到使用双指针来做，其中快指针i用于扫描所有的重复字符，而慢指针j则用于记录当前修改的位置。</p><p>首先快指针和慢指针都从0出发，快指针一直移动直到和慢指针所指向的字符不同。</p><p>此时快指针指向的位置减去慢指针指向的位置就是重复字符的长度。</p><p>将这段长度转化为字符串再转化为字符数组，再将字符数组中的元素一个个写入慢指针指向的位置。</p><p>特判一下长度为1的时候只要写入字符就可以。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compress</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> chars.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span>(idx &lt; n &amp;&amp; chars[idx] == chars[i]) idx++;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> idx - i;<br>        chars[j++] = chars[i];<br>        <span class="hljs-keyword">if</span>(cnt &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> idx - i;<br>            <span class="hljs-type">char</span>[] numArray = String.valueOf(len).toCharArray();<br>            <span class="hljs-keyword">for</span>(Character c : numArray)&#123;<br>                chars[j++] = c;<br>            &#125;<br>        &#125;<br>        i = idx;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 2130 maximum twin sum of a linked list</title>
    <link href="/2024/11/25/leetcode2130-maximum-twin-sum-of-a-linked-list/"/>
    <url>/2024/11/25/leetcode2130-maximum-twin-sum-of-a-linked-list/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>在一个大小为 <code>n</code> 且 <code>n</code> 为 偶数 的链表中，对于 <code>0 &lt;= i &lt;= (n / 2) - 1</code> 的 <code>i</code> ，第 <code>i</code> 个节点（下标从 <code>0</code> 开始）的孪生节点为第 <code>(n-1-i)</code> 个节点 。</p><ul><li>比方说，<code>n = 4</code> 那么节点 <code>0</code> 是节点 <code>3</code> 的孪生节点，节点 <code>1</code> 是节点 <code>2</code> 的孪生节点。这是长度为 <code>n = 4</code> 的链表中所有的孪生节点。</li></ul><p><strong>孪生和</strong> 定义为一个节点和它孪生节点两者值之和。</p><p>给你一个长度为偶数的链表的头节点 <code>head</code> ，请你返回链表的 <strong>最大孪生和</strong> 。<br><img src="/img/leetcode2130-maximum-twin-sum-of-a-linked-list-eg1drawio.png" alt="示例"></p><blockquote><p>输入：head &#x3D; [5,4,2,1]<br>输出：6<br><strong>解释：</strong><br>节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。<br>链表中没有其他孪生节点。<br>所以，链表的最大孪生和是 6 。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>孪生节点的思路类似于在一个数组中设置两个指针，一个从0开始一个从末尾开始相向而行，指针每次移动的数组下标之和则未孪生节点的和。</p><p>一个比较笨的办法是申请一个<code>ArrayList</code>，从<code>head</code>开始遍历链表，将所有的值存入<code>ArrayList</code>之中后按照访问数组的方式来计算。</p><p>但是这样的话会产生额外<code>O(n)</code>的空间。</p><p>在链表中想要从后往前找元素是非常困难的，能不能把换个思路，因为两个指针相向而行，把后一半的链表逆转过来，就可以比较方便地找到一个节点和它对应的孪生节点？</p><p>这里借鉴了<a href="https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/description/">2095.删除链表的中间节点</a>的思路，通过快慢指针来寻找到中间节点，然后把链表一分为二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(ListNode head)</span>&#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">guard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>,head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> guard;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> guard;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>            fast = fast.next;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>            fast = fast.next;<br>        <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">break</span>;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后将后半段链表逆置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.next;<br>        curr.next = prev;<br>        prev = curr;<br>        curr = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><p>两指针相向而行，最后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pairSum</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> findMiddle(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> mid.next;<br>        mid.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">revHead</span> <span class="hljs-operator">=</span> reverseList(tmp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span> &amp;&amp; revHead != <span class="hljs-literal">null</span>)&#123;<br>            max = Math.max(max, head.val + revHead.val);<br>            head = head.next;<br>            revHead = revHead.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br><br>    &#125;<br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">guard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>,head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> guard;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> guard;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>                fast = fast.next;<br>            <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>                fast = fast.next;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">break</span>;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：<code>O(n)</code>需要遍历两次链表<br>空间复杂度：<code>O(1)</code>需要申请常数级空间</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 2352 equal row and column pairs</title>
    <link href="/2024/11/24/leetcode2352-equal-row-and-column-pairs/"/>
    <url>/2024/11/24/leetcode2352-equal-row-and-column-pairs/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给你一个下标从 <code>0 </code>开始、大小为 <code>n x n</code>的整数矩阵 <code>grid</code> ，返回满足 <code>Ri</code> 行和 <code>Cj</code>列相等的行列对 <code>(Ri, Cj)</code> 的数目。<br>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p><p><img src="/img/leetcode2352-equal-row-and-column-pairs-ex1.jpg" alt="示例"></p><blockquote><p><strong>输入</strong>：grid &#x3D; [[3,2,1],[1,7,6],[2,7,7]]<br><strong>输出</strong>：1<br><strong>解释</strong>：存在一对相等行列对：</p><ul><li>(第 2 行，第 1 列)：[2,7,7]</li></ul></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一开始想到的朴素方法是选定一行之后依次比较每一行和每一列，这样的话时间复杂度会上升到$$ (O^3) $$，后续想到可以使用哈希表来做。<br>首先遍历行，将行转化为字符串之后存入哈希表，每遇到相同的字符串对应的值就+1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] row : grid)&#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : row)&#123;<br>        sb.append(num + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    hm.put(sb.toString(), hm.getOrDefault(sb.toString(), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就记录了所有的行和出现的对应次数。<br>随后遍历列，如果列在哈希表中出现，则相同数组的数量则增加对应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        sb.append(grid[j][i] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    ans += hm.getOrDefault(sb.toString(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一个触类旁通的思路"><a href="#一个触类旁通的思路" class="headerlink" title="一个触类旁通的思路"></a>一个触类旁通的思路</h1><p>通过StringBuilder()方法构建需要较高的系统开销。通过模拟哈希的过程则能避免这一点。</p><ul><li>首先选取一个较大的素数作为MODULOUS </li><li>随后选取一个较小的素数作为BASE</li><li>通过计算一行（或者一列）所有元素与BASE的乘积再对MODULOUS取余，则会生成独一无二的哈希值（不考虑碰撞）</li><li>将哈希值存入键值对</li><li>如果列数组计算出相同的哈希值，则认为两行相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BASE</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;  <span class="hljs-comment">// 基数，选择一个较大的质数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MODULUS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;  <span class="hljs-comment">// 模数，选择一个较大的质数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashKey</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            hashKey = (hashKey * BASE + grid[i][j] * (j + <span class="hljs-number">1</span>)) % MODULUS;<br>        &#125;<br>        map.put(hashKey, map.getOrDefault(hashKey, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashKey</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            hashKey = (hashKey * BASE + grid[i][j] * (i + <span class="hljs-number">1</span>)) % MODULUS;<br>        &#125;<br>        ans += map.getOrDefault(hashKey, <span class="hljs-number">0</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mit-6.s081-lab1</title>
    <link href="/2024/11/23/mit-6-s081-lab1/"/>
    <url>/2024/11/23/mit-6-s081-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="INTRO"><a href="#INTRO" class="headerlink" title="INTRO"></a>INTRO</h1><p>这篇blog主要用于记录MIT的操作系统实验(6.S081)Lab1的通过记录</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
