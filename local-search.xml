<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode2130-maximum-twin-sum-of-a-linked-list</title>
    <link href="/2024/11/25/leetcode2130-maximum-twin-sum-of-a-linked-list/"/>
    <url>/2024/11/25/leetcode2130-maximum-twin-sum-of-a-linked-list/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>在一个大小为 <code>n</code> 且 <code>n</code> 为 偶数 的链表中，对于 <code>0 &lt;= i &lt;= (n / 2) - 1</code> 的 <code>i</code> ，第 <code>i</code> 个节点（下标从 <code>0</code> 开始）的孪生节点为第 <code>(n-1-i)</code> 个节点 。</p><ul><li>比方说，<code>n = 4</code> 那么节点 <code>0</code> 是节点 <code>3</code> 的孪生节点，节点 <code>1</code> 是节点 <code>2</code> 的孪生节点。这是长度为 <code>n = 4</code> 的链表中所有的孪生节点。</li></ul><p><strong>孪生和</strong> 定义为一个节点和它孪生节点两者值之和。</p><p>给你一个长度为偶数的链表的头节点 <code>head</code> ，请你返回链表的 <strong>最大孪生和</strong> 。<br><img src="/img/leetcode2130-maximum-twin-sum-of-a-linked-list-eg1drawio.png" alt="示例"></p><blockquote><p>输入：head &#x3D; [5,4,2,1]<br>输出：6<br><strong>解释：</strong><br>节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。<br>链表中没有其他孪生节点。<br>所以，链表的最大孪生和是 6 。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>孪生节点的思路类似于在一个数组中设置两个指针，一个从0开始一个从末尾开始相向而行，指针每次移动的数组下标之和则未孪生节点的和。</p><p>一个比较笨的办法是申请一个<code>ArrayList</code>，从<code>head</code>开始遍历链表，将所有的值存入<code>ArrayList</code>之中后按照访问数组的方式来计算。</p><p>但是这样的话会产生额外<code>O(n)</code>的空间。</p><p>在链表中想要从后往前找元素是非常困难的，能不能把换个思路，因为两个指针相向而行，把后一半的链表逆转过来，就可以比较方便地找到一个节点和它对应的孪生节点？</p><p>这里借鉴了<a href="https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/description/">2095.删除链表的中间节点</a>的思路，通过快慢指针来寻找到中间节点，然后把链表一分为二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(ListNode head)</span>&#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">guard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>,head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> guard;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> guard;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>            fast = fast.next;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>            fast = fast.next;<br>        <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">break</span>;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后将后半段链表逆置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.next;<br>        curr.next = prev;<br>        prev = curr;<br>        curr = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><p>两指针相向而行，最后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pairSum</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> findMiddle(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> mid.next;<br>        mid.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">revHead</span> <span class="hljs-operator">=</span> reverseList(tmp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span> &amp;&amp; revHead != <span class="hljs-literal">null</span>)&#123;<br>            max = Math.max(max, head.val + revHead.val);<br>            head = head.next;<br>            revHead = revHead.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br><br>    &#125;<br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">guard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>,head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> guard;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> guard;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>                fast = fast.next;<br>            <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>)<br>                fast = fast.next;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">break</span>;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：<code>O(n)</code>需要遍历两次链表<br>空间复杂度：<code>O(1)</code>需要申请常数级空间</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode2352-equal-row-and-column-pairs</title>
    <link href="/2024/11/24/leetcode2352-equal-row-and-column-pairs/"/>
    <url>/2024/11/24/leetcode2352-equal-row-and-column-pairs/</url>
    
    <content type="html"><![CDATA[<h1 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h1><p>给你一个下标从 <code>0 </code>开始、大小为 <code>n x n</code>的整数矩阵 <code>grid</code> ，返回满足 <code>Ri</code> 行和 <code>Cj</code>列相等的行列对 <code>(Ri, Cj)</code> 的数目。<br>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p><p><img src="/img/leetcode2352-equal-row-and-column-pairs-ex1.jpg" alt="示例"></p><blockquote><p><strong>输入</strong>：grid &#x3D; [[3,2,1],[1,7,6],[2,7,7]]<br><strong>输出</strong>：1<br><strong>解释</strong>：存在一对相等行列对：</p><ul><li>(第 2 行，第 1 列)：[2,7,7]</li></ul></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一开始想到的朴素方法是选定一行之后依次比较每一行和每一列，这样的话时间复杂度会上升到$$ (O^3) $$，后续想到可以使用哈希表来做。<br>首先遍历行，将行转化为字符串之后存入哈希表，每遇到相同的字符串对应的值就+1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] row : grid)&#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : row)&#123;<br>        sb.append(num + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    hm.put(sb.toString(), hm.getOrDefault(sb.toString(), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就记录了所有的行和出现的对应次数。<br>随后遍历列，如果列在哈希表中出现，则相同数组的数量则增加对应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        sb.append(grid[j][i] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    ans += hm.getOrDefault(sb.toString(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一个触类旁通的思路"><a href="#一个触类旁通的思路" class="headerlink" title="一个触类旁通的思路"></a>一个触类旁通的思路</h1><p>通过StringBuilder()方法构建需要较高的系统开销。通过模拟哈希的过程则能避免这一点。</p><ul><li>首先选取一个较大的素数作为MODULOUS </li><li>随后选取一个较小的素数作为BASE</li><li>通过计算一行（或者一列）所有元素与BASE的乘积再对MODULOUS取余，则会生成独一无二的哈希值（不考虑碰撞）</li><li>将哈希值存入键值对</li><li>如果列数组计算出相同的哈希值，则认为两行相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BASE</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;  <span class="hljs-comment">// 基数，选择一个较大的质数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MODULUS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;  <span class="hljs-comment">// 模数，选择一个较大的质数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashKey</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            hashKey = (hashKey * BASE + grid[i][j] * (j + <span class="hljs-number">1</span>)) % MODULUS;<br>        &#125;<br>        map.put(hashKey, map.getOrDefault(hashKey, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashKey</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            hashKey = (hashKey * BASE + grid[i][j] * (i + <span class="hljs-number">1</span>)) % MODULUS;<br>        &#125;<br>        ans += map.getOrDefault(hashKey, <span class="hljs-number">0</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode Medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mit-6.s081-lab1</title>
    <link href="/2024/11/23/mit-6-s081-lab1/"/>
    <url>/2024/11/23/mit-6-s081-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="INTRO"><a href="#INTRO" class="headerlink" title="INTRO"></a>INTRO</h1><p>这篇blog主要用于记录MIT的操作系统实验(6.S081)Lab1的通过记录</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
